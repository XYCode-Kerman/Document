---
sidebar_position: 7
---

# Python 异步教程

Python 从 3.4 开始引入了 asyncio 库，提供异步协程支持，从 Python 3.4 到 3.7，对异步的支持一直在不断地进步。可以说，异步就是 Python 未来的趋势之一。

在了解异步之前，你可能已经接触过或听说过很多类似的概念，比如“并发”“并行”“多线程”等等，这么多名词，再加上一个“异步”，让人有些混乱。

不过，虽然看起来很复杂，但是，通过这篇教程，我相信你能够对“异步”和“协程”有一个清晰的把握。

以下是这篇教程涵盖的内容：

 - 异步：一种编程范式，独立于编程语言，可以具有多种语言的不同实现。
 - async/await：两个新的 Python 关键字，用于规定异步逻辑。
 - asyncio：一个 Python 内置的包，提供协程的基础功能和管理协程的方法。

## 什么是异步？

在讲异步之前，需要先知道一个与之相对的概念：同步。

其实同步对我们而言并不陌生。在接触到异步之前，我们认知的一切都是同步的。我们可以想象代码一句一句地执行，遇到函数就进入，执行完函数再执行函数后面的东西，所有的执行顺序都严格地和代码书写的顺序一致——这就是同步。

比如这样的代码：
```python
import time

print(1)
time.sleep(10)
print(2)
```

我们可以清晰地预知它的行为：先打印 1，然后等待 10 秒，最后打印 2。

同步最大的优点是**思路清晰**。**你永远可以知道你的程序是按照怎样的顺序执行的，不用担心任何意料之外的情况**。

但同时，同步也有不可避免的缺点：在某些情境下，它会带来性能的浪费。

以一个生活中的场景为例：你在网上下载一个文件，但是文件很大，需要很长时间才能下完。这时候，你肯定不会盯着进度条一点点走，而是去做点别的事情，读一会书，看一会电影，之类的。

但如果有一个完全“同步”的人，他为自己设定的程序是下载这个文件，然后运行它，这样的话，他为了不让自己的运行逻辑乱掉，就会一直守在电脑前，直到文件下载完成才做下一步的工作。正常人肯定不能忍受这样无聊的等待，也不会希望自己的程序在这种无聊的事上浪费时间。

为了能充分利用这些可能被浪费掉的时间，人们想出过很多方法，比如**多线程**，比如**回调**。

多线程是最容易想到的一种方式了。我们可以创建多个线程，每个线程内部是同步的，再让这些线程同时运行。这样，在一个线程等待的时候，其余的线程可以继续运行，不会因此停止。

这看上去十分美好，然而现实并不像我们想象得那么简单。虽然线程各自内部的代码是同步的，但不同线程之间的代码执行顺序已经无从确定。换言之，我们引入了“异步”。**代码的执行顺序与书写顺序不一致的现象就是异步**。

熟悉多线程的人应该了解过“锁”的各种花样。两个线程共享资源时，如果同时对同一个变量进行修改，就有可能导致出乎预料的情况。所以人们发明了“锁”，来保证同一时刻只有唯一的线程对某一个变量进行修改。可以说，“锁”是为了制服异步而发明的。

```mermaid
graph TD;
    subgraph 执行顺序
    H{{b = 1}} --> F[a = 1]
    F --> G{{a += b}}
    G --> I["print(a)"]
    end
	subgraph Thread1
	A[a = 1] --> B["print(a)"]
	B --> E([Output: 2])
	end
	subgraph Thread2
	C{{b = 1}} --> D{{a += b}}
	D -.->|Breaking!| E
	end
```

如此看来，异步似乎是一件不太好的事情。它让程序的运行平添了一种不可控的随意性，我们不再能看到代码就直接推演出结果，因为即使是相邻书写的僵局代码，之间也可能会有别的代码执行。

但是**异步相较于同步而言，带来的性能提升实在是太诱人了**。一个网站的服务器，如果是同步的，那么它同时只能让一个用户访问——这简直是不可理喻的事情。异步就像几万年前蹲踞在草原清冷的月光下，用锐利的眼神眺望人类营地篝火的一只秀美的狼，而猎手们则思考着如何给它套上项圈，变成自己忠实的猎犬。

所以，多线程、回调，包括协程，这一系列设计，与其说是为了充分利用计算资源，不如说是为了在人类可理解的范畴内，更好地制服异步。

## 锁的“困境”

多线程和锁的结合，至今仍然是异步编程的最佳选择之一。因此，怎么加锁、在何处加锁，就成为了一门重要的学问。

锁是个好东西，但是不能有太多。一方面，反复地获取锁释放锁会占用运行时间；另一方面，当一个线程长时间持有某个锁时，其他的线程如果想要哦访问这个资源，也必须在原地等待，**极端情况下，同一时间只有一个线程在执行！**

人们在优化锁的使用上花了很大工夫，从中衍生出的各种理论此处不再赘述。随着锁的使用方式逐渐变得复杂，人们发现，如果想要完美地控制锁的粒度，就不得不对花大量的代码去精细地控制每一个锁，这让编写代码的难度大大提高了。

有的时候，控制锁带来的复杂度已经超出了人能忍受的范围。于是我们经常见到许多简单粗暴的操作——比如在 CPython 中臭名昭著的 GIL。它将整个 Python 解释器加锁，来彻底解决 Python 代码内的线程冲突问题；后果就是，**所有的 Python 线程都必须等待这个锁，硬生生地让多线程程序几乎退化成了单线程**。

当然，GIL 的存在也没有完全把多线程的优点抹消掉。比如一个线程在 `sleep` 的时候，或者在等待网络请求返回的时候，还是会乖乖地释放掉 GIL 锁，让其他线程运行的。不过这时候，释放 GIL 的线程实际上只是在等着，什么都不干，最后还是只有一个线程在运行。

**既然还是只有一个线程在运行，那么为什么不干脆用单线程实现呢？**

答案是：当然可以。对于这个问题，人们给出了许多答案，其中最著名的是两种：**回调和 CPS，以及协程**。

## 回调和 CPS

介绍了这么多，我们终于第一次提到了“协程”这个词。不过先不要着急，我们先来看看另一种实现：回调和 CPS。

大家应该对回调（callback）比较耳熟。将程序的一部分写成回调函数。

🚧施工中🚧